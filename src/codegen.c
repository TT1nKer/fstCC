#include "codegen.h"

/* Global code buffer */
CodeBuffer code_buffer;

void code_buffer_init(void) {
    code_buffer.output = malloc(8192);
    code_buffer.size = 0;
    code_buffer.capacity = 8192;
}

void code_emit(char *format, ...) {
    va_list args;
    va_start(args, format);

    char temp[512];
    int len = vsnprintf(temp, sizeof(temp), format, args);

    if (code_buffer.size + len >= code_buffer.capacity) {
        code_buffer.capacity *= 2;
        code_buffer.output = realloc(code_buffer.output, code_buffer.capacity);
    }

    strcpy(code_buffer.output + code_buffer.size, temp);
    code_buffer.size += len;

    va_end(args);
}

/* Generate code for program */
void generate_program(ASTNode *node) {
    if (!node || node->type != AST_PROGRAM) return;

    code_emit("# Generated by fstCC - Bootstrap C Compiler\n");
    code_emit("# Target: x86-64 Linux (AT&T Syntax)\n\n");
    code_emit(".section .text\n");
    code_emit(".global _start\n\n");

    for (int i = 0; i < node->data.program.function_count; i++) {
        generate_function(node->data.program.functions[i]);
    }

    code_emit("_start:\n");
    code_emit("    call main\n");
    code_emit("    movq %%rax, %%rdi    # main's return value becomes exit code\n");
    code_emit("    movq $60, %%rax      # sys_exit\n");
    code_emit("    syscall\n\n");
}

/* Generate code for function definition */
void generate_function(ASTNode *node) {
    if (!node || node->type != AST_FUNCTION_DEF) return;

    symbol_table_init();

    code_emit("%s:\n", node->data.function_def.name);
    code_emit("    pushq %%rbp\n");
    code_emit("    movq %%rsp, %%rbp\n");

    generate_compound_stmt(node->data.function_def.body);

    code_emit("    movq $0, %%rax       # default return 0\n");
    code_emit("    movq %%rbp, %%rsp\n");
    code_emit("    popq %%rbp\n");
    code_emit("    ret\n\n");
}

/* Generate code for compound statement */
void generate_compound_stmt(ASTNode *node) {
    if (!node || node->type != AST_COMPOUND_STMT) return;

    for (int i = 0; i < node->data.stmt_list.statement_count; i++) {
        generate_statement(node->data.stmt_list.statements[i]);
    }
}

/* Generate code for statement */
void generate_statement(ASTNode *node) {
    if (!node) return;

    switch (node->type) {
        case AST_VARIABLE_DECL:
            generate_variable_decl(node);
            break;
        case AST_RETURN_STMT:
            generate_return_stmt(node);
            break;
        case AST_EXPRESSION_STMT:
            generate_expression_stmt(node);
            break;
        case AST_COMPOUND_STMT:
            generate_compound_stmt(node);
            break;
        default:
            printf("Warning: Unhandled statement type in code generation\n");
            break;
    }
}

/* Generate code for variable declaration */
void generate_variable_decl(ASTNode *node) {
    if (!node || node->type != AST_VARIABLE_DECL) return;

    symbol_table_add(node->data.var_decl.name);

    if (node->data.var_decl.initializer) {
        generate_expression(node->data.var_decl.initializer);

        int offset = symbol_table_lookup(node->data.var_decl.name);
        code_emit("    movq %%rax, %d(%%rbp)  # store in %s\n",
                 offset, node->data.var_decl.name);
    }
}

/* Generate code for return statement */
void generate_return_stmt(ASTNode *node) {
    if (!node || node->type != AST_RETURN_STMT) return;

    if (node->data.return_stmt.expression) {
        generate_expression(node->data.return_stmt.expression);
    } else {
        code_emit("    movq $0, %%rax       # return 0\n");
    }

    code_emit("    movq %%rbp, %%rsp\n");
    code_emit("    popq %%rbp\n");
    code_emit("    ret\n");
}

/* Generate code for expression statement */
void generate_expression_stmt(ASTNode *node) {
    if (!node || node->type != AST_EXPRESSION_STMT) return;

    if (node->data.return_stmt.expression) {
        generate_expression(node->data.return_stmt.expression);
    }
}

/* Generate code for expression */
void generate_expression(ASTNode *node) {
    if (!node) return;

    switch (node->type) {
        case AST_BINARY_OP:
            generate_binary_op(node);
            break;
        case AST_IDENTIFIER:
            generate_identifier(node);
            break;
        case AST_NUMBER:
            generate_number(node);
            break;
        default:
            printf("Warning: Unhandled expression type in code generation\n");
            break;
    }
}

/* Generate code for binary operation */
void generate_binary_op(ASTNode *node) {
    if (!node || node->type != AST_BINARY_OP) return;

    generate_expression(node->data.binary_op.left);
    code_emit("    pushq %%rax          # save left operand\n");

    generate_expression(node->data.binary_op.right);
    code_emit("    movq %%rax, %%rbx    # right operand in rbx\n");
    code_emit("    popq %%rax           # restore left operand\n");

    switch (node->data.binary_op.operator) {
        case TOKEN_PLUS:
            code_emit("    addq %%rbx, %%rax    # left + right\n");
            break;
        case TOKEN_MINUS:
            code_emit("    subq %%rbx, %%rax    # left - right\n");
            break;
        case TOKEN_MULTIPLY:
            code_emit("    imulq %%rbx, %%rax   # left * right\n");
            break;
        case TOKEN_DIVIDE:
            code_emit("    cqto                 # sign extend rax to rdx:rax\n");
            code_emit("    idivq %%rbx          # left / right\n");
            break;
        default:
            printf("Warning: Unhandled binary operator in code generation\n");
            break;
    }
}

/* Generate code for identifier */
void generate_identifier(ASTNode *node) {
    if (!node || node->type != AST_IDENTIFIER) return;

    int offset = symbol_table_lookup(node->data.identifier.name);
    code_emit("    movq %d(%%rbp), %%rax  # load %s\n",
             offset, node->data.identifier.name);
}

/* Generate code for number */
void generate_number(ASTNode *node) {
    if (!node || node->type != AST_NUMBER) return;

    code_emit("    movq $%d, %%rax      # load constant %d\n",
             node->data.number.value, node->data.number.value);
}
